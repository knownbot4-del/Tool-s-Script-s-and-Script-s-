import socket
import config
import requests
import json  # Importat pentru raport
import subprocess
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
from VULN_DB import VULN_DB

URL = config.DISCORD_WEBHOOK
numepc = "127.0.0.1"  # Èšinta ta

# ListÄƒ globalÄƒ pentru stocarea rezultatelor Ã®n vederea salvÄƒrii JSON
scan_results = []

# --- FUNCTII UTILS ---

def detect_os(ip):
    try:
        # DetectÄƒm platforma pentru a folosi flag-ul corect de ping (-c pentru Linux, -n pentru Windows)
        import platform
        param = "-n" if platform.system().lower() == "windows" else "-c"
        output = subprocess.check_output(f"ping {param} 1 {ip}", shell=True, stderr=subprocess.STDOUT).decode()

        ttl_match = re.search(r"ttl=(\d+)", output.lower())
        if ttl_match:
            ttl = int(ttl_match.group(1))
            if ttl <= 64: return "ğŸ§ Linux/Unix "
            if ttl <= 128: return "ğŸªŸ Windows "
            if ttl <= 255: return "ğŸŒ Network Device"
    except:
        return "â“ Unknown OS (Host unreachable/ICMP Blocked)"
    return "â“ Unknown OS"

def send_msg(text):
    try:
        requests.post(URL, json={"content": text})
    except Exception as e:
        print(f"Eroare Discord: {e}")

def check_vulnerabilities(banner_text):
    for version, threat in VULN_DB.items():
        if isinstance(version, str) and version in banner_text:
            return f"ğŸš¨ **VULNERABILITATE GÄ‚SITÄ‚:** `{version}`\n> âš ï¸ *AmeninÈ›are:* {threat}"
    return None

# --- LOGICA DE SCANARE ---

def scan_port(port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1.5)

    try:
        result = s.connect_ex((numepc, port))

        if result == 0:
            port_info = {
                "port": port,
                "timestamp": datetime.now().strftime("%H:%M:%S"),
                "status": "Open",
                "vulnerabilities": None
            }
            
            msg_vuln = ""
            if port in VULN_DB:
                info = VULN_DB[port]
                port_info["vulnerabilities"] = info
                msg_vuln = (f"âš ï¸ **[ VULN DB MATCH ]**\n"
                            f"Port: `{port}` ({info.get('service')})\n"
                            f"Risc: `{info.get('risk')}`")

            # Banner Grabbing
            banner_text = "N/A"
            try:
                s.send(b"Hello\r\n")
                banner = s.recv(1024)
                if banner:
                    banner_text = banner.decode(errors='ignore').strip()
            except:
                pass
            
            port_info["banner"] = banner_text
            scan_results.append(port_info) # SalvÄƒm Ã®n listÄƒ pentru JSON

            # Trimitem raportul pe Discord
            report = f"ğŸ¯ **{numepc}:{port}**\nâœ… Port DESCHIS"
            if msg_vuln: report += f"\n{msg_vuln}"
            if banner_text != "N/A": report += f"\nğŸ“œ **Banner:** `{banner_text[:100]}`"
            
            send_msg(report)
            print(f"âœ… [+] Port {port} raportat.")

    except Exception as e:
        pass
    finally:
        s.close()

# --- SALVARE RAPORT ---

def save_json_report():
    filename = f"scan_{numepc.replace('.', '_')}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    report_data = {
        "target": numepc,
        "os_detected": detect_os(numepc),
        "scan_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "open_ports": scan_results
    }
    with open(filename, "w", encoding="utf-8") as f:
        json.dump(report_data, f, indent=4)
    print(f"\nğŸ“Š Raport salvat Ã®n: {filename}")

# --- MAIN ---

if __name__ == "__main__":
    os_info = detect_os(numepc)
    print(f"ğŸš€ Pornim scanarea pe {numepc} ({os_info})...")
    send_msg(f"ğŸ **Start Scanare:** `{numepc}`\nğŸ•µï¸ **OS Detectat:** {os_info}")

    with ThreadPoolExecutor(max_workers=50) as executor:
        executor.map(scan_port, range(1, 1025))

    save_json_report()
    print("ğŸ Gata! Raportul JSON a fost generat.")
